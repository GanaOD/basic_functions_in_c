# Problem-Solving Methodology

## Core Framework
1. **Analysis Phase**
   - Break down the problem to its mathematical/logical essence
   - Identify patterns, invariants, and constraints
   - Connect to known theoretical frameworks (graph theory, dynamic programming, etc.)

2. **Design Phase**
   - Sketch abstract solution approaches (2-3 different paradigms)
   - Evaluate space/time complexity tradeoffs
   - Select approach based on elegance and efficiency criteria

3. **Implementation Phase**
   - Translate mathematical model to code
   - Address edge cases systematically
   - Apply memory management discipline

4. **Refinement Phase**
   - Optimize for clarity first, performance second
   - Identify opportunities for mathematical simplification
   - Apply security hardening principles

## Language-Specific Approaches
- **C**: Memory management strategies, pointer discipline patterns
- **Haskell**: Type-driven development, composition patterns

## Domain-Specific Approaches
- **Algorithm Problems**: Complexity analysis first, implementation second
- **Systems Problems**: Interface design first, implementation second